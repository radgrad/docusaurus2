(window.webpackJsonp=window.webpackJsonp||[]).push([[280],{338:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(2),o=n(6),r=(n(0),n(345)),i={title:"How to write acceptance tests",sidebar_label:"Write acceptance tests"},s={unversionedId:"developers/testing/howto/write-acceptance-tests",id:"developers/testing/howto/write-acceptance-tests",isDocsHomePage:!1,title:"How to write acceptance tests",description:"We use TestCafe a node.js tool to automate acceptance (i.e. end-to-end)  testing.",source:"@site/docs/developers/testing/howto/write-acceptance-tests.md",slug:"/developers/testing/howto/write-acceptance-tests",permalink:"/docs/developers/testing/howto/write-acceptance-tests",version:"current",lastUpdatedBy:"Philip Johnson",lastUpdatedAt:1604690829,sidebar_label:"Write acceptance tests",sidebar:"mainSidebar",previous:{title:"How to write integration tests",permalink:"/docs/developers/testing/howto/write-integration-tests"},next:{title:"How to perform testing with different roles",permalink:"/docs/developers/testing/howto/perform-testing-with-different-roles"}},c=[{value:"Running acceptance tests during development",id:"running-acceptance-tests-during-development",children:[]},{value:"Running acceptance tests for continuous integration",id:"running-acceptance-tests-for-continuous-integration",children:[]},{value:"Goal of acceptance testing",id:"goal-of-acceptance-testing",children:[]},{value:"Page Object Model",id:"page-object-model",children:[]}],l={rightToc:c};function p(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"We use ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://devexpress.github.io/testcafe/"}),"TestCafe")," a node.js tool to automate acceptance (i.e. end-to-end)  testing."),Object(r.b)("p",null,"We use the Page Object Model to simplify acceptance test development."),Object(r.b)("h2",{id:"running-acceptance-tests-during-development"},"Running acceptance tests during development"),Object(r.b)("p",null,"To run acceptance tests while you are developing them, there are two steps. First, bring up an instance of RadGrad in one command shell with the development database fixture:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ meteor npm run start\n")),Object(r.b)("p",null,'Then, create a second command shell, and invoke TestCafe in "development" mode:'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ meteor npm run test-acceptance-development\n")),Object(r.b)("p",null,"When you invoke TestCafe in this fashion, it will display a Chrome browser and you can watch the acceptance tests as they execute. This is very useful for seeing when and how your test fails."),Object(r.b)("h2",{id:"running-acceptance-tests-for-continuous-integration"},"Running acceptance tests for continuous integration"),Object(r.b)("p",null,'For continuous integration, or for other "batch" command situations, it is inappropriate to have to run an instance of RadGrad in a separate command shell, and/or have Chrome windows popping up on your screen.'),Object(r.b)("p",null,'So, to simply run the acceptance tests "in background", and have a development version of RadGrad automatically instantiated and terminated, invoke the acceptance tests this way:'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ meteor npm run test-acceptance\n")),Object(r.b)("h2",{id:"goal-of-acceptance-testing"},"Goal of acceptance testing"),Object(r.b)("p",null,'In RadGrad2, the goal of acceptance testing is to assess "availability", which is defined operationally as follows:'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"All pages (and their internal components) display successfully. This verifies that there are no fatal errors in the implementation of the UI component code. It does not verify that what is displayed is correct under all circumstances.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"All pages that should display data from the database, when initialized with the default development data, should have non-empty results.  This verifies that data can be retrieved from the database and displayed. It does not verify that the correct dataset has been retrieved under all circumstances.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"All user input mechanisms (i.e. forms) work for at least one set of legal inputs. This verifies that data can be added and retrieved from the database. It does not verify that forms work under all conditions."))),Object(r.b)("p",null,'The goal of assessing "availability" is motivated by the following considerations:'),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'We want to increase the velocity of development by helping developers quickly assess whether or not their changes had a dramatic "ripple" effect, particularly when doing UI development. If all acceptance tests pass, then developers know that their changes did not produce fatal errors anywhere in the user interface.')),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"With a small development resources, we do not want the development and maintenance of tests to consume too much of our development team's time and energy.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'Since the user interface and functionality of the system is in flux, we want to reduce the "test maintainance" burden as much as possible. We don\'t want small UI changes to require acceptance test code modification.'))),Object(r.b)("h2",{id:"page-object-model"},"Page Object Model"),Object(r.b)("p",null,'Acceptance tests are designed using the "Page Object Model".  This means that each page, and in some cases component, will have a corresponding Javascript class that is responsible for providing methods to manipulate the UI components on that page.'),Object(r.b)("p",null,"Here is a simple example of a RadGrad class supporting acceptance testing according to the Page Object Model:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"import { Selector } from 'testcafe';\nimport { NavBar } from './navbar.component';\n\nconst navBar = new NavBar();\n\nexport class SigninPage {\n  constructor() {\n    this.pageId = '#signin-page';\n    this.pageSelector = Selector(this.pageId);\n  }\n\n  /** Checks that this page is currently displayed. */\n  async isDisplayed(testController) {\n    await testController.expect(this.pageSelector.exists).ok();\n  }\n\n  /** Fills out and submits the form to signin, then checks to see that login was successful. */\n  async signin(testController, credentials) {\n    await this.isDisplayed(testController);\n    await testController.typeText('#signin-form-email', credentials.username);\n    await testController.typeText('#signin-form-password', credentials.password);\n    await testController.click('#signin-form-submit');\n    await navBar.isLoggedIn(testController, credentials.username);\n  }\n}\n")),Object(r.b)("p",null,"This class illustrates some common design patterns for acceptance testing using the Page Object Model in RadGrad:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A constructor along with an isDisplayed() method that defines an HTML ID that can be used to identify whether or not the page is currently visible. Acceptance tests will typically use HTML IDs to select elements of a page, though this is not required.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"HTML IDs have naming conventions in RadGrad.  Here are some of them:"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'Most pages should have a top-level ID that can be used in acceptance testing to assess whether the correct page is being displayed (and, more importantly, that no fatal error has occurred while attempting to display it). One possible naming convention for this ID is the page name, followed by "-page". For example, "signin-page". In the case of pages that vary by role, then the convention is the role name (i.e. "student", "admin"), followed by the type of page (i.e. "-home"), followed by "-page". For example, "student-home-page".')),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'For forms directly embedded in a page, the naming convention is the page name, followed by "-form-", followed by the field name.  For example, "signin-form-email".')),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'For React components embedded in a page, the naming convention is the component name, optionally followed by a unique string if necessary. For example, "retrieve-user-tab-students" identifies the "students" tab of the "retrieve-user" component.')),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'Note that HTML IDs should only contain letters, numbers, underscore, dash, and the dot (.). More specifically, the at-sign character ("@") is not legal (at least for HTML 4). Thus, do not create IDs that are email addresses!  The naming convention for IDs that must indicate a user is just their account name (i.e. "abi"), not their username (i.e. "',Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"mailto:abi@hawaii.edu"}),"abi@hawaii.edu"),'"). This should not cause any problems for acceptance testing using the default dataset.'))))))}p.isMDXComponent=!0},345:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return b}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),p=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=p(n),m=a,b=d["".concat(i,".").concat(m)]||d[m]||u[m]||r;return n?o.a.createElement(b,s(s({ref:t},l),{},{components:n})):o.a.createElement(b,s({ref:t},l))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);